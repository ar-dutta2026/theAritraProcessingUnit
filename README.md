# theAritraProcessingUnit
<pre> # theAritraProcessingUnit (tAPU) The **Aritra Processing Unit**, aka **tAPU**, is a custom 9-bit instruction, 8-register processor written entirely in SystemVerilog. It includes: - A compact RISC-like instruction set - A Python **assembler** that converts human-readable assembly into 9-bit machine code + LUT files - Full Quartus + QuestaSim workflow - Three fully working programs: - **Program 1:** Hamming distance - **Program 2:** Multiply `A * B` - **Program 3:** Multiply `A * B * C` (24-bit result) The design is fully synthesizable for the **Intel Arria II GX FPGA** and supports simulation through **QuestaSim**. --- # üìÅ Repository Layout ``` theAritraProcessingUnit/ ‚îú‚îÄ‚îÄ ProcessorArchitecture/ # SystemVerilog CPU core + memory + ROM/LUT ‚îú‚îÄ‚îÄ Assembler/ # Python assembler ‚îú‚îÄ‚îÄ TestBenches/ # Testbenches for each program ‚îî‚îÄ‚îÄ README.md ``` --- # ‚öôÔ∏è CPU Architecture ## Datapath Overview - **9-bit fixed-width instructions** - **8 general-purpose registers (`R0‚ÄìR7`)** - **Instruction ROM (`inst_rom`)** Loads program from `program*_machinecode.txt` - **Fetch Unit** Handles PC, branching, instruction fetching, LUT-based control - **ALU** Implements addition, subtraction, logical ops (as defined in `definitions.sv`) - **Data Memory** Read/write RAM for program data - **Register File** 8√ó(data width) registers (configurable in `definitions.sv`) - **Top-Level Processor** Wires everything together into a complete CPU All key parameters (widths, opcodes, memory sizes) are centrally defined inside: ``` ProcessorArchitecture/definitions.sv ``` This file must be compiled **first** in Questa or Quartus. --- ## üóÇ Register File | Register | Width | Typical Use (program convention) | |---------|--------------|----------------------------------------------| | **R0** | data width | Zero register (manually cleared via `SUB`) | | **R1** | data width | Base pointers, counters | | **R2** | data width | Memory base pointer | | **R3** | data width | Temporary register | | **R4** | data width | Partial results | | **R5** | data width | Temporary / carry | | **R6** | data width | Flags / sign storage | | **R7** | data width | Scratch | > These roles are *not* enforced by hardware ‚Äì just a pattern used in example programs. --- ## üìê Instruction Format (Conceptual) Instructions are **9 bits total**, encoding: - **Opcode** - **Register fields** - **Immediate / offset fields** The *exact* bit positions are defined in `definitions.sv` and mirrored in the Python assembler. ### Instruction Types #### Data Movement | Mnemonic | Description | |------------------------|-----------------------------------------------| | `LI Rd, imm` | Load small immediate | | `LW Rd, offset(Rb)` | Load from memory | | `SW Rs, offset(Rb)` | Store to memory | #### Arithmetic & Logical | Mnemonic | Description | |------------------|--------------------------------------------| | `ADD Rd, Rs` | `Rd = Rd + Rs` | | `SUB Rd, Rs` | `Rd = Rd - Rs` | #### Control Flow | Mnemonic | Description | |-----------------------|--------------------------------------| | `BEQ Ra, Rb, label` | Branch if equal | | `BNE Ra, Rb, label` | Branch if not equal | | `J label` | Unconditional jump | (Hardware/assembler names may vary slightly.) --- # üß∞ Assembler (Python) Located in: ``` Assembler/ ``` The assembler: 1. Parses assembly into tokens 2. Validates that every instruction fits the 9-bit ISA 3. Generates: - `programX_machinecode.txt` ‚Üí for `inst_rom` - `lut_pX.txt` ‚Üí for the fetch unit's LUT 4. Throws friendly errors if: - Immediate out of range - Invalid register - Unknown mnemonic - Hardware cannot encode the instruction Output files drop straight into the SystemVerilog processor with no manual modification. --- # üõ† Synthesizing in Quartus (Arria II GX) ### 1. Add CPU HDL files Import **all files** from: ``` ProcessorArchitecture/ ``` Ensure `definitions.sv` is ordered first. ### 2. Device Selection Set Quartus device family to: ``` Intel Arria II GX ``` Pick your exact FPGA model. ### 3. Program Selection (Program 1/2/3) Inside `inst_rom` and `fetch_unit`: - Use the correct pair of text files: | Program | Machine Code File | LUT File | |---------|--------------------------------|------------------| | 1 | `program1_machinecode.txt` | `lut_p1.txt` | | 2 | `program2_machinecode.txt` | `lut_p2.txt` | | 3 | `program3_machinecode.txt` | `lut_p3.txt` | Ensure the selected lines are **uncommented**. ### 4. Run Synthesis From Quartus: ``` Processing ‚Üí Start ‚Üí Analysis & Synthesis ``` (Optional: Run fitter + timing for full FPGA compile.) --- # üß™ Simulation in QuestaSim ### 1. Load Files Add: - All SystemVerilog files from `ProcessorArchitecture/` - Testbench from `TestBenches/` - The correct `program*_machinecode.txt` and `lut_p*.txt` ### 2. Compile (must compile definitions first) ```tcl vlog ProcessorArchitecture/definitions.sv vlog ProcessorArchitecture/*.sv vlog TestBenches/*.sv ``` ### 3. Run testbench Questa will complain about memory access. Suppress warning **7061**: ```tcl vsim -suppress 7061 work.test_bench run -all ``` You can then inspect: - Registers - Data memory - ALU operations - PC + instruction flow --- # üìò Example Programs ## Program 1 ‚Äî Hamming Distance **Goal:** Count how many positions differ between two sequences. ### What the assembly does: 1. Initialize pointers to both sequences 2. Zero a counter in memory 3. Loop: - Load byte from A - Load byte from B - Compare - If different ‚Üí increment counter 4. Store final Hamming distance to memory Essentially: ``` distance = sum over i of (A[i] != B[i]) ``` --- ## Program 2 ‚Äî Multiply A * B **Goal:** Multiply two signed 8-bit numbers using shift-and-add. ### Assembly behavior: 1. Clear product registers 2. Determine result sign (track negative operands) 3. Convert operands to positive magnitudes 4. Perform **shift-and-add multiply**: - If LSB of B = 1 ‚Üí add A into product - Shift A left - Shift B right 5. Apply sign to the final product 6. Store result into `mem[3..]` This is the classical software multiplier. --- ## Program 3 ‚Äî Multiply A * B * C (24-bit result) **Goal:** Compute a full 24-bit three-operand signed product. ### Memory Layout | Address | Meaning | |--------:|------------------------| | `0` | A | | `1` | B | | `2` | C | | `3` | Product low byte | | `4` | Product mid byte | | `5` | Product high byte | | `6` | Sign flag | ### Assembly behavior: 1. Clear `mem[3..5]` (24-bit accumulator) 2. Cleanup and normalize signs of A/B/C 3. Multiply A and B using shift-and-add (Program 2 logic) 4. Multiply the intermediate product by C - Use multi-byte shift-and-add - Maintain carries across 3 bytes 5. Apply final sign to full 24-bit result 6. Store result in `mem[3..5]` (little endian) Result = **A * B * C** stored as a signed 24-bit value. --- # üßë‚Äçüíª How to Add Your Own Programs 1. Write assembly using existing ISA 2. Run the Python assembler to generate: - `programX_machinecode.txt` - `lut_pX.txt` 3. Point `inst_rom` & `fetch_unit` to these files 4. Simulate or synthesize normally --- # ‚úîÔ∏è Final Notes - `definitions.sv` **must** be compiled before every other file - Programs 1‚Äì3 are fully tested on both QuestaSim & Quartus - Assembler enforces the ISA restrictions to prevent illegal encodings - The processor is fully modular ‚Äî new instructions can be added by updating: - hardware (decoder + ALU) - assembler opcode definitions --- </pre>
